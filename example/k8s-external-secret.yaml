# Example configuration for using an external imagePullSecret
#
# This example shows how to configure Rise to use a pre-existing imagePullSecret
# instead of having the controller manage it automatically.
#
# Use case: Static Docker registries where credentials are managed externally
# (e.g., manually created secrets, sealed-secrets, external-secrets operator)

server:
  host: "0.0.0.0"
  port: 3000
  public_url: "${PUBLIC_URL:-http://localhost:3000}"
  cookie_secure: false
  jwt_signing_secret: "${RISE_JWT_SIGNING_SECRET}"

auth:
  issuer: "${DEX_ISSUER:-http://localhost:5556/dex}"
  client_id: "${OIDC_CLIENT_ID:-rise-backend}"
  client_secret: "${OIDC_CLIENT_SECRET:-rise-backend-secret}"
  admin_users:
    - "admin@example.com"

database:
  url: "${DATABASE_URL}"

# Registry configuration for a static Docker registry
# When using oci-client-auth, users must be logged in locally for pushing images
registry:
  type: "oci-client-auth"
  registry_url: "registry.example.com"
  namespace: "rise-apps"
  client_registry_url: "registry.example.com"  # Public URL for CLI push operations

# Kubernetes controller with external imagePullSecret
deployment_controller:
  type: "kubernetes"
  ingress_class: "nginx"
  production_ingress_url_template: "{project_name}.apps.example.com"
  staging_ingress_url_template: "{project_name}-{deployment_group}.preview.example.com"
  auth_backend_url: "http://rise-backend.default.svc.cluster.local:3000"
  auth_signin_url: "https://rise.example.com"
  
  # Reference an external imagePullSecret that must exist in each project namespace
  # The controller will NOT create or manage this secret
  image_pull_secret_name: "my-registry-secret"

  # Optional: TLS configuration for ingresses
  ingress_tls_secret_name: "rise-apps-tls"
  ingress_annotations:
    cert-manager.io/cluster-issuer: "letsencrypt-prod"

# How to create the secret in each namespace:
#
# kubectl create secret docker-registry my-registry-secret \
#   --docker-server=registry.example.com \
#   --docker-username=myuser \
#   --docker-password=mypassword \
#   -n rise-my-app
#
# Or using sealed-secrets:
#
# kubectl create secret docker-registry my-registry-secret \
#   --docker-server=registry.example.com \
#   --docker-username=myuser \
#   --docker-password=mypassword \
#   --dry-run=client -o yaml | \
#   kubeseal -o yaml > sealed-secret.yaml
#
# kubectl apply -f sealed-secret.yaml -n rise-my-app
